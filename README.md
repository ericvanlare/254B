254B
====

254B Code

#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in3,    lightLeft,      sensorReflection)
#pragma config(Sensor, in4,    lightMiddle,    sensorReflection)
#pragma config(Sensor, in5,    lightRight,     sensorReflection)
#pragma config(Sensor, in6,    leftArm,        sensorPotentiometer)
#pragma config(Sensor, in7,    rightArm,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftFrontEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightFrontEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  jumperLeft,     sensorTouch)
#pragma config(Sensor, dgtl7,  jumperRight,    sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           FrontRight,    tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port4,           FrontLeft,     tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port5,           BackLeft,      tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port6,           BackRight,     tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port7,           LeftLift,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           RightLift,     tmotorVex393, openLoop)
#pragma config(Motor,  port9,           Intake,        tmotorVex269, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/*
Motor and Sensor Map
-----------------------
	LS9{ }	 { }LS9
	| |  |ln4 |	 | |
   | |  |    |	 | |
   | |  |	 |	 | |
	| |  |	 |	 | |
   | |  \  	 /  | |
HS4| |   ----   | |HS2
	| |jmp6	jmp7| |
HS5| |__________| |HS6
  ln5	2HS7  2HS8 ln3
*/

//Functions
void drive(int power) {
	motor[port4] = motor[port5] = motor[port2] = motor[port6] = power;
}

void ldrive(int power) {
	motor[port4] = motor[port5] = power;
}

void rdrive(int power) {
	motor[port2] = motor[port6] = power;
}

void lift(int power) {
	motor[port7] = motor[port8] = power;
}

void goStraightFor (float distance) { //Fix it so that there are two different types of encoders (front are two-wire, back are integrated)
	//Might be a cause for errors if it turns/jolts around too mu
	float traveled = 0;
	int factor;
	if (distance < 0){
	factor = -1;
	}
	else{
	factor = 1;
	}
	while(traveled < abs(distance)){
		traveled = nMotorEncoder[BackLeft] * 3.14159/90;
		//Circular distance = pi * 4 in * (degrees/360)
		motor[port5] = 120 * factor;
		if (nMotorEncoder[BackLeft] < SensorValue[leftFrontEncoder]){
			motor[port4] = 113 * factor;
		}
		else if (nMotorEncoder[BackLeft] == SensorValue[leftFrontEncoder]){
			motor[port4] = 120 * factor;
		}
		else if (nMotorEncoder[BackLeft] > SensorValue[leftFrontEncoder]){
			motor[port4] = 127 * factor;
		}
		if (nMotorEncoder[BackLeft] < SensorValue[rightFrontEncoder]){
			motor[port2] = 113 * factor;
		}
		else if (nMotorEncoder[BackLeft] == SensorValue[rightFrontEncoder]){
			motor[port2] = 120 * factor;
		}
		else if (nMotorEncoder[BackLeft] > SensorValue[rightFrontEncoder]){
			motor[port2] = 127 * factor;
		}
		if (nMotorEncoder[BackLeft] < nMotorEncoder[BackRight]){
			motor[port6] = 113 * factor;
		}
		else if (nMotorEncoder[BackLeft] == nMotorEncoder[BackRight]){
			motor[port6] = 120 * factor;
		}
		else if (nMotorEncoder[BackLeft] > nMotorEncoder[BackRight]){
			motor[port6] = 127 * factor;
		}
	}
	drive(0);
	nMotorEncoder[BackLeft] = 0;
	nMotorEncoder[BackRight] = 0;
	SensorValue[leftFrontEncoder] = 0;
	SensorValue[rightFrontEncoder] = 0;
}

void turn90Right (){
	motor[port4] = 127; //Front left
	motor[port6] = -127; //Back right
	int one = 0;
	int two = 0;
	while (one + two < 3){
		if (SensorValue[leftFrontEncoder] > 8){
			motor[port4] = 0; //Front left
			one = 1;
		}
		if (nMotorEncoder[BackRight] > 8){
			motor[port6] = 0; //Back right
			two = 2;
		}
	}
	nMotorEncoder[BackLeft] = 0;
	nMotorEncoder[BackRight] = 0;
	SensorValue[leftFrontEncoder] = 0;
	SensorValue[rightFrontEncoder] = 0;
}

void turn90Left (){
	motor[port2] = 127; //Front right
	motor[port5] = -127; //Back left
	int one = 0;
	int two = 0;
	while (one + two < 3){
		if (SensorValue[rightFrontEncoder] > 8){
			motor[port2] = 0; //Front right
			one = 1;
		}
		if (nMotorEncoder[BackLeft] > 8){
			motor[port5] = 0; //Back left
			two = 2;
		}
	}
	nMotorEncoder[BackLeft] = 0;
	nMotorEncoder[BackRight] = 0;
	SensorValue[leftFrontEncoder] = 0;
	SensorValue[rightFrontEncoder] = 0;
}

//For the following three functions, use sensor reading to find actual min. and max. potentiometer values for arm.
void liftFull (){
	while((SensorValue(rightArm) + SensorValue(leftArm))/2 < 1000){
		lift(127);
	}
	lift(0);
}

void stayAtHeight (){
	lift(20);
}

void liftLowerFull (){
	while((SensorValue(rightArm) + SensorValue(leftArm))/2 > 500){
		lift(-127);
	}
	lift(0);
}

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
  nMotorEncoder[BackLeft] = 0;
	nMotorEncoder[BackRight] = 0;
	SensorValue[leftFrontEncoder] = 0;
	SensorValue[rightFrontEncoder] = 0;
}

task autonomous(){
	int side = 0;
	if (SensorValue[jumperRight])
		side = 1;
	int zone = 0;
	if (SensorValue[jumperLeft])
		zone = 1;
	//0 is red, 1 is blue
	//0 is middle, 1 is far zone
	if (zone == 0){
		motor[port9] = -127;
		wait1Msec(100);
		//Stage 1- start by pointing robot at the middle big ball
		goStraightFor(50);
		liftFull();
		stayAtHeight();
		goStraightFor(5);
		goStraightFor(-5);
		liftLowerFull();
		goStraightFor(-50);
		//Stage 2- reposition robot so it is on the edge of the field facing straight
		//Possible to use line sensors at this point (maybe add in later)
		goStraightFor(55);
		if (side == 0){
			turn90Right();
			turn90Right();
		}
		else if (side == 1){
			turn90Left();
			turn90Left();
		}
		liftFull();
		stayAtHeight();
		motor[port9] = -127;
		goStraightFor(5);
		wait1Msec(1000);
		motor[port9] = 0;
		goStraightFor(-5);
		if (side == 0){
			turn90Right();
			turn90Right();
		}
		else if (side == 1){
			turn90Left();
			turn90Left();
		}
		goStraightFor(10);
		motor[port9] = 127;
		wait1Msec(1500);
		goStraightFor(-5);
		motor[port9] = 0;
		liftLowerFull();
	//Fix functions for lifting (has to be at different heights) by testing potentiometers
	//Add version for back- fix below
	}
	/*else if (zone == 1){
		drive(127);
		wait1Msec(1000);7
		if (side == 0)rdrive(127);
		else if (side == 1) ldrive(127);
		wait1Msec(500);
		drive(127);
		intake(127);
		wait1Msec(2000);
		if (side == 0)rdrive(127);
		else if (side == 1) ldrive(127);
		wait1Msec(300);
		drive(127);
		lift(127);
		wait1Msec(2000);
		lift(20);
		intake(-127);
		wait1Msec(1000);
		intake(0);
		drive(-127);
		wait1Msec(500);
		drive(0);
		lift(-127);
		wait1Msec(300);
	}*/
}

task usercontrol() {
	while(true) {
		motor[port4] = motor[port5] = vexRT[Ch3]; //Left Drive set to left stick y-axis
		motor[port2] = motor[port6] = vexRT[Ch2]; //Right Drive set to right stick y-axis

		//Lift
		if (vexRT[Btn5U])
			motor[port7] = motor[port8] = 127; //Front left shoulder button raises lift
		else if (vexRT[Btn5D])
			motor[port7] = motor[port8] = -127; //Back left shoulder button lowers lift
		else if (vexRT[Btn7U])
			motor[port7] = motor[port8] = 20;
		else
			motor[port7] = motor[port8] = vexRT[Ch3Xmtr2]; //If driver isn't operating, sets it to operator's controller

		//Intake
		if (vexRT[Btn6U])
			motor[port9] = 127; //Front right shoulder button outakes
		else if (vexRT[Btn6D])
			motor[port9] = -127; //Back right shoulder button intakes
		else
			motor[port9] = vexRT[Ch2Xmtr2]; //If driver isn't operating, sets it to operator's controller
	}
}

/*
vexRT
Channel variable names:

Ch1 - X-Axis - Right Joystick
Ch2 - Y-Axis - Right Joystick

Ch3 - Y-Axis - Left Joystick
Ch4 - X-Axis - Left Joystick


Button variable names:

Btn5U - Button group 5 - "U" (up)
Btn5D - Button group 5 - "D" (down)

Btn6U - Button group 6 - "U" (up)
Btn6D - Button group 6 - "D" (down)

Btn7U - Button group 7 - "U" (up)
Btn7D - Button group 7 - "D" (down)
Btn7L - Button group 7 - "L" (left)
Btn7R - Button group 7 - "R" (right)

Btn8U - Button group 8 - "U" (up)
Btn8D - Button group 8 - "D" (down)
Btn8L - Button group 8 - "L" (left)
Btn8R - Button group 8 - "R" (right)



Channel variable names for VEXnet Transmitter 2:

Ch1Xmtr2 - X-Axis - Right Joystick
Ch2Xmtr2 - Y-Axis - Right Joystick

Ch3Xmtr2 - Y-Axis - Left Joystick
Ch4Xmtr2 - X-Axis - Left Joystick


Button variable names for VEXnet Transmitter 2:

Btn5UXmtr2 - Button group 5 - "U" (up)
Btn5DXmtr2  - Button group 5 - "D" (down)

Btn6UXmtr2 - Button group 6 - "U" (up)
Btn6DXmtr2 - Button group 6 - "D" (down)

Btn7UXmtr2 - Button group 7 - "U" (up)
Btn7DXmtr2 - Button group 7 - "D" (down)
Btn7LXmtr2 - Button group 7 - "L" (left)
Btn7RXmtr2 - Button group 7 - "R" (right)

Btn8UXmtr2 - Button group 8 - "U" (up)
Btn8DXmtr2 - Button group 8 - "D" (down)
Btn8LXmtr2 - Button group 8 - "L" (left)
Btn8RXmtr2 - Button group 8 - "R" (right)
*/

			motor[intake]= -127;
		}
		else if (vexRT[Btn5U] == 1){
			motor[intake]= 127;
		}
		else if (vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0]{
			motor[intake] = 0;
		}
	}
}

